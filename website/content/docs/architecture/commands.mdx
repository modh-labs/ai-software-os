---
title: "Commands Overview"
description: "6 workflow shortcuts that automate common development tasks like auditing, migrations, features, PRs, reviews, and testing."
---

# Commands Overview

The AI Software OS includes **6 commands** as workflow shortcuts.

| Command | Description |
|---------|-------------|
| Audit | Comprehensive codebase audit for architecture, testing, code quality, and reliability tracking |
| Create Migration | Guide through schema-first database migration workflow |
| New Feature | Scaffold a new feature with route, actions, components, and types |
| PR | Create a pull request with proper formatting and commit analysis |
| Review | Review recent code changes against your project's coding standards and patterns |
| Test | Run tests and analyze failures with fix suggestions |

## Command Details

### Audit


# Codebase Audit

**Audit Target**: `$ARGUMENTS`

## Overview

This command performs a comprehensive audit of your codebase, covering:

1. **Architecture & Code Quality** - Route colocation, import patterns, type safety
2. **Data Fetching Patterns** - Server Actions, repositories, Server Components
3. **Testing Coverage & Quality** - Unit tests, integration tests, coverage metrics
4. **Reliability & Production Health** - PostHog error tracking, performance metrics
5. **Best Practices Compliance** - Adherence to team standards

## Audit Process

### Phase 1: Scope & Context Gathering

**I'll start by understanding what you want to audit and why.**

#### Step 1: PostHog MCP Connection Check

**Optional but recommended for production insights.**

I'll check if PostHog MCP is connected to provide:
- Error rates and patterns
- Performance metrics
- Feature flag usage
- User journey analytics

**If PostHog MCP is not connected**, you can set it up with:

```bash
npx @posthog/wizard mcp add

# Or manually:
claude mcp add-json posthog -s user '{
  "command": "npx",
  "args": ["-y", "mcp-remote@latest", "https://mcp.posthog.com/sse", "--header", "Authorization:${POSTHOG_AUTH_HEADER}"],
  "env": {"POSTHOG_AUTH_HEADER": "Bearer YOUR_API_KEY"}
}'
```

Get your API key from: https://app.posthog.com/settings/user-api-keys?preset=mcp_server

**I'll continue with the audit regardless of PostHog availability**, but production insights will be limited.

#### Step 2: Audit Scope Clarification

**If you didn't specify a path**, I'll ask:

1. **What do you want to audit?**
   - Specific route (e.g., `app/(protected)/calls`)
   - Specific component (e.g., `CallItem.tsx`)
   - Entire protected routes (`app/(protected)`)
   - Specific feature area (e.g., scheduler, dashboard)

2. **What's the primary goal?**
   - Pre-launch review (comprehensive)
   - Bug investigation (focused on reliability)
   - Code quality improvement (architecture + testing)
   - Performance optimization (PostHog metrics + code patterns)
   - Migration planning (e.g., Apollo â†’ Relay equivalent)

3. **Specific concerns or areas of focus?**
   - Testing gaps
   - Type safety issues
   - Performance problems
   - Error rates in production
   - Server Action patterns
   - Repository usage
   - All of the above

4. **Known context to consider?**
   - Recent production issues
   - Feature flags active
   - Migration status
   - Upcoming launches

---

### Phase 2: Architecture & Code Quality Analysis

#### Section 1: File Structure & Organization

**I'll analyze:**

âœ… **Route Colocation Compliance**
- Components in `components/` directory
- Server Actions in `actions.ts` or `actions/`
- Types in `types.ts`
- Hooks in `hooks/`
- No cross-route imports

âœ… **No Barrel Files**
- Check for `index.ts` files (anti-pattern)
- Verify direct imports

âœ… **Import Organization**
- React/Next.js first
- External dependencies
- Internal (@/ alias)
- Relative imports

**Example findings:**

```markdown
### âŒ Route Colocation Violations

**File**: `app/(protected)/calls/components/CallItem.tsx`
- **Line 5**: Importing from `../../scheduler/components/TimeSlotPicker`
- **Impact**: Creates tight coupling between routes
- **Fix**: Move `TimeSlotPicker` to `app/_shared/components/` or duplicate logic

**File**: `app/(protected)/dashboard/index.ts`
- **Issue**: Barrel file detected
- **Impact**: Slow build times, circular import risk
- **Fix**: Remove barrel file, use direct imports
```

#### Section 2: Type Safety Audit

**I'll check:**

âœ… **Supabase-Generated Types Usage**
- NO custom interfaces for database tables
- Use `Database["public"]["Tables"]["table_name"]["Row|Insert|Update"]`
- Check for manual type definitions (anti-pattern)

âœ… **TypeScript Strict Mode Compliance**
- No `any` types
- No `@ts-ignore` comments
- Proper null/undefined handling

âœ… **Zod Validation**
- Server Actions validate input
- Proper error formatting
- Type inference from schemas

**Example findings:**

```markdown
### âŒ Type Safety Issues

**File**: `app/(protected)/calls/actions.ts`
- **Line 15**: `const data: any = await supabase...`
- **Impact**: No type safety, runtime errors possible
- **Fix**: Use `Call` type from repository or Supabase-generated types

**File**: `app/(protected)/scheduler/types.ts`
- **Lines 10-25**: Custom `BookingLink` interface duplicates database schema
- **Impact**: Type drift from database, maintenance burden
- **Fix**: Remove interface, import from `database.types.ts`

```typescript
// âŒ Current
export interface BookingLink {
  id: string;
  title: string;
  // ... 15 more fields manually defined
}

// âœ… Fix
import type { Database } from "@/app/_shared/lib/supabase/database.types";
export type BookingLink = Database["public"]["Tables"]["call_booking_links"]["Row"];
```
```

#### Section 3: Server Action Patterns

**I'll verify:**

âœ… **Required Patterns**
- `"use server"` directive at top
- Structured response type: `{ success, data?, error?, errors? }`
- `revalidatePath()` called after mutations
- Pino logger usage (NOT `console.log`)
- Repository usage (NOT direct `supabase.from()`)
- Zod validation for input

**Example findings:**

```markdown
### âŒ Server Action Anti-Patterns

**File**: `app/(protected)/calls/actions.ts`

**Missing `revalidatePath()`**:
- **Line 45**: `createCallAction` mutates data but doesn't invalidate cache
- **Impact**: UI shows stale data until manual refresh
- **Fix**:
```typescript
export async function createCallAction(input: unknown) {
  // ... validation and mutation logic

  revalidatePath("/calls");        // âœ… Add this
  revalidatePath("/dashboard");    // âœ… Add this

  return { success: true, data: call };
}
```

**Direct Supabase Usage**:
- **Lines 25-30**: Direct `supabase.from("calls").insert()` call
- **Impact**: Bypasses repository layer, duplicates query logic
- **Fix**:
```typescript
// âŒ Current
const { data, error } = await supabase
  .from("calls")
  .insert(callData)
  .select("*")
  .single();

// âœ… Fix
import { createCall } from "@/app/_shared/repositories/calls.repository";
const call = await createCall(supabase, callData);
```

**Missing Logger**:
- **Line 50**: Using `console.error()` instead of Pino
- **Fix**:
```typescript
import { createModuleLogger } from "@/app/_shared/lib/logger";
const logger = createModuleLogger("calls-actions");

logger.error(error, "Failed to create call");
```
```

#### Section 4: Repository Pattern Compliance

**I'll verify:**

âœ… **Repository Standards**
- Accept `SupabaseClient` as first parameter
- Use `select *` for full type safety
- Use Supabase-generated `Insert|Update|Row` types
- Export individual functions (not objects)
- Let RLS handle `organization_id` filtering

**Example findings:**

```markdown
### âš ï¸ Repository Pattern Violations

**File**: `app/_shared/repositories/calls.repository.ts`

**Not using `select *`**:
- **Line 15**: Selecting specific fields breaks type inference
- **Fix**:
```typescript
// âŒ Current
.select("id, title, scheduled_at")

// âœ… Fix
.select("*")
// TypeScript now infers the full Call type!
```

**Missing Relations**:
- **Query doesn't join related data** (lead, closer, payments)
- **Impact**: Multiple queries needed, N+1 problem
- **Fix**:
```typescript
const selectStr = `
  *,
  lead:leads!calls_lead_id_fkey(*),
  closer:users!calls_closer_id_fkey(*),
  payments!payments_call_id_fkey(*)
`;

return supabase.from("calls").select(selectStr);
```
```

---

### Phase 3: Testing Coverage & Quality

#### Section 1: Test File Coverage

**I'll identify missing tests:**

âœ… **Component Tests**
- Every component in `components/` should have a `.test.tsx` file
- Coverage should be > 70% for critical components

âœ… **Server Action Tests**
- Every action should test validation, success, and error paths
- Verify `revalidatePath()` is called

âœ… **Repository Tests**
- Unit tests for query building and filtering logic
- Mock Supabase client appropriately

**Example findings:**

```markdown
### âŒ Missing Test Coverage

**Components without tests:**
- `app/(protected)/calls/components/CallItem.tsx` (HIGH PRIORITY)
- `app/(protected)/calls/components/CallDetails.tsx` (HIGH PRIORITY)
- `app/(protected)/scheduler/components/BookingLinkCard.tsx` (MEDIUM)

**Server Actions without tests:**
- `app/(protected)/calls/actions.ts` - `cancelCallAction` (HIGH PRIORITY)
- `app/(protected)/scheduler/create/actions.ts` - `createBookingLinkAction` (HIGH PRIORITY)

**Repositories without tests:**
- `app/_shared/repositories/booking-link.repository.ts` (MEDIUM PRIORITY)

**Impact**:
- Cannot safely refactor or modify these files
- Breaking changes go undetected until production
- No confidence in edge case handling
```

#### Section 2: Test Quality Analysis

**I'll review existing tests for:**

âœ… **Good Practices**
- No snapshot tests
- Realistic test data (faker.js)
- Factory functions for setup
- Proper mocking (external deps only)
- Arrange-Act-Assert structure
- Descriptive test names

âœ… **Coverage Metrics**
- Check `vitest.config.ts` thresholds
- Run coverage report if requested

**Example findings:**

```markdown
### âš ï¸ Test Quality Issues

**File**: `app/(protected)/calls/components/__tests__/CallItem.test.tsx`

**Overmocking**:
- **Lines 10-20**: Mocking internal utility functions
- **Impact**: Tests don't validate real behavior
- **Fix**: Only mock external dependencies (SWR, Supabase)

**Hardcoded Test Data**:
- **Line 25**: Using `"John Doe"` instead of `faker.person.fullName()`
- **Impact**: Tests less robust, don't catch edge cases
- **Fix**:
```typescript
import { faker } from "@faker-js/faker";

const mockCall: Call = {
  id: faker.string.uuid(),
  title: faker.lorem.words(3),
  scheduled_at: faker.date.future().toISOString(),
  // ...
};
```

**Missing Edge Cases**:
- No tests for loading states
- No tests for error states
- No tests for empty data
```

---

### Phase 4: Reliability & Production Health (PostHog MCP)

**If PostHog MCP is available**, I'll query production metrics:

âœ… **Error Tracking**
- Recent errors related to audited code
- Error frequency and trends
- Stack traces and context

âœ… **Performance Metrics**
- Slow queries or Server Actions
- Client-side performance issues
- Time to interactive

âœ… **Feature Flags**
- Active flags affecting the code
- Rollout status and user targeting

âœ… **User Journeys**
- Drop-off points in flows
- Common user paths
- Session replays for bugs

**Example findings:**

```markdown
### ðŸš¨ Production Issues (PostHog Insights)

**Error Rate Spike**:
- **Route**: `/calls/create`
- **Error**: "Validation failed: scheduled_at is required"
- **Frequency**: 45 errors in the last 7 days
- **Impact**: Users unable to create calls
- **Root Cause**: Client-side validation missing, server-side validation rejecting
- **Fix**: Add client-side Zod validation before Server Action call

**Performance Degradation**:
- **Route**: `/dashboard`
- **Issue**: Time to interactive > 3 seconds (P95)
- **Root Cause**: Loading all 500+ calls without pagination
- **Fix**: Implement server-side pagination in `getCalls` repository function

**Feature Flag Usage**:
- **Flag**: `new-scheduler-ui`
- **Status**: 50% rollout
- **Impact**: Audited code (`scheduler/create/page.tsx`) is behind flag
- **Note**: Ensure tests cover both old and new UI paths
```

---

### Phase 5: Synthesis & Recommendations

**After completing the analysis, I'll provide:**

#### 1. Executive Summary

```markdown
# Audit Summary: `app/(protected)/calls`

## Health Score: 65/100 ðŸŸ¡

### Quick Stats:
- **Files Analyzed**: 15
- **Critical Issues (P0)**: 3
- **High Priority (P1)**: 7
- **Medium Priority (P2)**: 12
- **Low Priority (P3)**: 5
- **Test Coverage**: 35% (Target: 70%+)
- **Type Safety**: 80% (8 `any` types found)

### Top Concerns:
1. âŒ Zero test coverage for `CallItem.tsx` (most complex component)
2. âŒ Missing `revalidatePath()` in 3 Server Actions
3. âŒ Direct Supabase usage in 2 Server Actions (bypass repositories)
4. âš ï¸ 45 production errors in `/calls/create` (last 7 days)
```

#### 2. Prioritized Issues (P0/P1/P2/P3)

```markdown
## Critical Issues (P0) - Fix Immediately

### P0-1: Missing Test Coverage for CallItem.tsx
- **File**: `app/(protected)/calls/components/CallItem.tsx`
- **Impact**: Most complex component (200+ lines) with zero tests
- **Risk**: High - any refactor or change could break functionality
- **Effort**: 4-6 hours
- **Action**: Create comprehensive test suite covering:
  - Loading states
  - User interactions (expand/collapse)
  - SWR data fetching
  - Error handling

### P0-2: Missing revalidatePath() in cancelCallAction
- **File**: `app/(protected)/calls/actions.ts:45`
- **Impact**: UI shows stale data after cancellation until manual refresh
- **Risk**: High - user confusion, potential data inconsistency
- **Effort**: 5 minutes
- **Action**:
```typescript
export async function cancelCallAction(callId: string) {
  // ... existing logic

  revalidatePath("/calls");        // âœ… Add this
  revalidatePath("/dashboard");    // âœ… Add this

  return { success: true };
}
```

### P0-3: Production Errors in /calls/create (45 errors/week)
- **File**: `app/(protected)/calls/create/page.tsx`
- **Impact**: Users unable to create calls
- **Root Cause**: Missing client-side validation
- **Effort**: 2 hours
- **Action**: Add Zod validation in form component before Server Action call

## High Priority (P1) - Address This Sprint

[... detailed list of P1 issues ...]

## Medium Priority (P2) - Next 2-3 Sprints

[... detailed list of P2 issues ...]

## Low Priority (P3) - Backlog

[... detailed list of P3 issues ...]
```

#### 3. Immediate Actions (This Week)

```markdown
## Immediate Actions

1. **Add Test Coverage for CallItem.tsx** (P0-1)
   - Create `CallItem.test.tsx`
   - Use factory function pattern from `docs/TESTING-BEST-PRACTICES.md`
   - Aim for 80%+ coverage

2. **Fix revalidatePath() in Server Actions** (P0-2)
   - `calls/actions.ts:45` - `cancelCallAction`
   - `calls/actions.ts:70` - `updateCallAction`
   - `scheduler/create/actions.ts:30` - `createBookingLinkAction`

3. **Add Client-Side Validation** (P0-3)
   - Create Zod schema in `calls/create/schema.ts`
   - Validate in form component before Server Action
   - Show validation errors to user immediately
```

#### 4. Short-Term Improvements (Next 2-3 Sprints)

```markdown
## Short-Term Improvements

1. **Migrate to Repository Pattern** (P1)
   - Remove direct `supabase.from()` calls in Server Actions
   - Use repository functions exclusively
   - Estimated effort: 4-6 hours

2. **Improve Type Safety** (P1)
   - Remove 8 instances of `any` types
   - Replace custom interfaces with Supabase-generated types
   - Estimated effort: 2-3 hours

3. **Add Integration Tests** (P1)
   - Test full call creation flow
   - Test call cancellation flow
   - Estimated effort: 6-8 hours
```

#### 5. Long-Term Considerations (Roadmap)

```markdown
## Long-Term Improvements

1. **Performance Optimization** (P2)
   - Implement pagination for calls list (500+ records)
   - Add virtual scrolling for large datasets
   - Optimize database queries with indexes

2. **Error Boundary Implementation** (P2)
   - Add error boundaries to catch component failures
   - Provide user-friendly error messages
   - Track errors to PostHog

3. **Accessibility Audit** (P3)
   - Ensure keyboard navigation works
   - Add ARIA labels
   - Test with screen readers
```

#### 6. Next Steps

```markdown
## Recommended Next Steps

1. **Prioritize P0 issues** - Fix today
2. **Create tracking tickets** - For P1+ issues (see below)
3. **Schedule team review** - Discuss findings and approach
4. **Update documentation** - Reflect new patterns

### Create Tracking Tickets?

I can help create GitHub issues for the identified gaps. Would you like me to:
- âœ… Create issues for P0 items (3 issues)
- âœ… Create issues for P1 items (7 issues)
- â­ï¸ Skip P2/P3 for now
```

---

### Phase 6: Interactive Follow-Up

**After delivering the report, I'll ask:**

#### 1. Deep Dive Options

```
Which area needs deeper investigation?

1. **Architecture** - Drill into specific violations
2. **Testing** - Generate test templates for missing tests
3. **Performance** - Analyze PostHog metrics in detail
4. **Security** - Check for vulnerabilities (exposed secrets, SQL injection)
5. **All of the above**
```

#### 2. Issue Creation Workflow

**IMPORTANT**: I will NEVER create GitHub issues without your explicit confirmation for each issue.

**Step 1: Offer to Create Issues**

```
I've identified 3 P0 gaps and 7 P1 gaps. Would you like me to create GitHub issues to track these?

Options:
- âœ… Yes, show me previews first
- â­ï¸ No, I'll create them manually
```

**Step 2: Present Each Issue for Approval**

For each proposed issue, I'll use `AskUserQuestion` to show you:

```markdown
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“‹ Issue Preview [1] of [10]

**Title**: [P0] CallItem.tsx - Zero test coverage

**Labels**: `p0`, `testing`, `frontend`, `calls`

**Body**:
## Problem
The `CallItem` component has no unit tests, integration tests, or Storybook stories, creating high risk of regressions.

## Impact
- Cannot safely refactor or modify component
- No visual regression testing
- Breaking changes go undetected until production

## Files Affected
- `app/(protected)/calls/components/CallItem.tsx` (200 lines, high complexity)

## Action Items
- [ ] Create `CallItem.test.tsx` with factory function pattern
- [ ] Test loading states, user interactions, SWR data fetching
- [ ] Test error handling and edge cases
- [ ] Achieve 80%+ coverage

## References
- Audit Report: `audit-report-calls-2025-01-13.md`
- Testing Guide: `docs/TESTING-BEST-PRACTICES.md`
- Example Test: `app/_shared/modules/kpi/components/__tests__/AnalyticsKPI.test.tsx`

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Create this issue in GitHub?

Options:
- âœ… Yes, create this issue
- âœï¸ Edit first (tell me what to change)
- â­ï¸ Skip this one
- ðŸ›‘ Stop - cancel all remaining
```

**Step 3: Create Issue (Only After Approval)**

If you approve, I'll create the issue and show you:

```
âœ… Created: Issue #123 - [P0] Zero test coverage for CallItem.tsx
Link: https://github.com/[YOUR_ORG]/[YOUR_REPO]/issues/123
```

**Step 4: Summary**

```
âœ… GitHub Issue Creation Complete

Created 3 issues:
- #123: [P0] Zero test coverage for CallItem.tsx
- #124: [P0] Missing revalidatePath() in cancelCallAction
- #125: [P0] Production errors in /calls/create

Skipped 1 issue:
- [P2] Extract magic numbers to constants (you chose to skip)

All issue links saved in audit report: `audit-report-calls-2025-01-13.md`
```

#### 3. Export Options

```
Would you like me to:

1. **Export audit report** - Save as Markdown file in `docs/audits/`
2. **Generate test templates** - Scaffolded test files for missing coverage
3. **Create migration plan** - Step-by-step guide for fixing issues
4. **Audit related components** - Continue with connected routes/components
5. **All of the above**
```

---

## Documentation References

I will reference these key docs during the audit:

- **Frontend Best Practices**: `docs/FE-BEST-PRACTICES.md`
- **Testing Best Practices**: `docs/TESTING-BEST-PRACTICES.md`
- **Repository Patterns**: `app/_shared/repositories/CLAUDE.md`
- **CLAUDE.md**: Root-level guidance for the entire codebase

---

## Usage Examples

```bash
# Audit a specific route
/audit app/(protected)/calls

# Audit a specific component
/audit app/(protected)/calls/components/CallItem.tsx

# Audit entire protected routes
/audit app/(protected)

# Audit shared repositories
/audit app/_shared/repositories

# Audit specific feature area
/audit app/(protected)/scheduler

# Audit with context (in your message)
/audit app/(protected)/dashboard
# "I'm seeing slow load times and errors in production. Focus on performance and reliability."
```

---

## Principles

1. **Conversational & Adaptive**: I'll ask clarifying questions rather than make assumptions
2. **Read-Only Analysis**: All audit analysis uses read-only operations
3. **Explicit Approval for Actions**: Issue creation requires your approval for EACH item
4. **Context-Aware**: I'll reference team docs and coding standards
5. **Actionable**: Findings include specific recommendations with line numbers and code examples
6. **Prioritized**: Issues are ranked by impact and effort (P0/P1/P2/P3)
7. **Graceful Degradation**: Audit continues even if PostHog MCP isn't available

---

## Safety Guarantees

- âœ… No issues created without your explicit "Yes" approval
- âœ… Full preview shown before any write operation
- âœ… Can edit, skip, or stop at any time
- âœ… All operations logged in audit report for reference
- âœ… Read-only analysis - no code changes during audit

---

## Notes

- Audit analysis is completely **read-only** - no code changes, no commits
- GitHub issue creation is **OPTIONAL** and requires explicit approval for each issue
- PostHog MCP connection is **optional** but provides richer production insights
- The audit adapts based on your responses and available tools
- All findings reference **specific files and line numbers**
- Recommendations align with **team standards and best practices**
- You can **stop issue creation at any time** during the process

---

**Ready to start? I'll begin by checking PostHog MCP and asking about your audit goals.**

### Create Migration


# Create Migration Command

Guide through the schema-first database migration workflow.

**Migration Name**: `$ARGUMENTS`

## Workflow Overview

```
1. Update domain.sql  â†’  2. Run db diff  â†’  3. Review  â†’  4. Apply  â†’  5. Generate types
```

## Step 1: Identify the Domain

First, let me check which domain file to update:

```bash
ls supabase/schemas/
```

Domain files:
- `booking.sql` - Booking links, configurations
- `calls.sql` - Calls, outcomes, recordings
- `leads.sql` - Leads, contacts
- `organizations.sql` - Organizations, settings
- `payments.sql` - Stripe payments
- `users.sql` - Users, team members

## Step 2: Describe Your Change

I'll ask what change you want to make:

1. **Add column to existing table** - Which table? What column? Type? Nullable?
2. **Create new table** - What's it called? What columns?
3. **Modify column** - Which column? What change?
4. **Add index** - Which table/column(s)?
5. **Add RLS policy** - Which table? What policy?

## Step 3: Update Domain SQL

I'll update the appropriate `supabase/schemas/*.sql` file with your changes.

### For New Tables

```sql
CREATE TABLE table_name (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id text NOT NULL,
  -- your columns here
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE INDEX idx_table_org ON table_name(organization_id);

ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;

CREATE POLICY "org_isolation" ON table_name
  FOR ALL USING (organization_id = (auth.jwt() ->> 'org_id')::text);
```

### For New Columns

```sql
ALTER TABLE existing_table ADD COLUMN column_name type;
```

## Step 4: Generate Migration

```bash
bun run supabase db diff -f $ARGUMENTS --linked
```

## Step 5: Review Generated SQL

```bash
cat supabase/migrations/*_$ARGUMENTS.sql
```

I'll verify:
- [ ] Correct table/column definitions
- [ ] RLS policies included
- [ ] No unintended changes
- [ ] Safe migration patterns

## Step 6: Apply Migration

```bash
bun run supabase db push --linked
```

## Step 7: Generate Types

```bash
npm run db:types
```

## Step 8: Update Repository (if needed)

If you added a new table, you may need to create a repository file:
- Location: `app/_shared/repositories/table-name.repository.ts`
- Follow patterns in `.claude/skills/repository-pattern/SKILL.md`

## Checklist

- [ ] Domain SQL file updated
- [ ] Migration generated with `db diff`
- [ ] Migration reviewed for correctness
- [ ] Migration applied with `db push`
- [ ] Types regenerated with `db:types`
- [ ] Repository created/updated if needed
- [ ] All files committed together

## Common Patterns

### Adding Nullable Column (Safe)
```sql
ALTER TABLE users ADD COLUMN avatar_url text;
```

### Adding Column with Default (Safe)
```sql
ALTER TABLE users ADD COLUMN is_active boolean DEFAULT true;
```

### Adding NOT NULL Column (Multi-Step)
```sql
-- Step 1: Add nullable
ALTER TABLE users ADD COLUMN timezone text;
-- Run migration, backfill data
-- Step 2: Add constraint (separate migration)
ALTER TABLE users ALTER COLUMN timezone SET NOT NULL;
```

### New Feature


# New Feature Command

Scaffold a new feature with proper structure and patterns.

**Feature Name**: `$ARGUMENTS`

## What This Command Creates

```
app/(protected)/$ARGUMENTS/
â”œâ”€â”€ page.tsx                 # Server Component with data fetching
â”œâ”€â”€ actions.ts               # Server Actions (colocated)
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ${Feature}List.tsx   # Main list component
â”‚   â”œâ”€â”€ ${Feature}Item.tsx   # Individual item with Sheet details
â”‚   â””â”€â”€ ${Feature}Form.tsx   # Create/edit form
â””â”€â”€ types.ts                 # Route-specific types (if needed)
```

## Step 1: Gather Requirements

I'll ask about your feature:

1. **What data does this feature work with?**
   - Existing table(s)?
   - Need new table(s)?

2. **What are the main operations?**
   - List/view items
   - Create new items
   - Edit existing items
   - Delete items

3. **Does it need a detail view?**
   - Sheet panel (like Calls)?
   - Separate page?

## Step 2: Create Directory Structure

```bash
mkdir -p app/(protected)/$ARGUMENTS/components
```

## Step 3: Create Server Component Page

```typescript
// app/(protected)/$ARGUMENTS/page.tsx
import { createClient } from "@/app/_shared/lib/supabase/server";
import { get${Feature}s } from "@/app/_shared/repositories/${feature}.repository";
import { ${Feature}PageClient } from "./components/${Feature}PageClient";

export default async function ${Feature}Page() {
  const supabase = await createClient();
  const items = await get${Feature}s(supabase);

  return <${Feature}PageClient items={items} />;
}
```

## Step 4: Create Server Actions

```typescript
// app/(protected)/$ARGUMENTS/actions.ts
"use server";

import { revalidatePath } from "next/cache";
import { createModuleLogger } from "@/app/_shared/lib/logger";
import { createClient } from "@/app/_shared/lib/supabase/server";
import {
  create${Feature},
  update${Feature},
  delete${Feature},
} from "@/app/_shared/repositories/${feature}.repository";

const logger = createModuleLogger("${feature}-actions");

export async function create${Feature}Action(input: ${Feature}Insert) {
  logger.info("Creating ${feature}");

  try {
    const supabase = await createClient();
    const item = await create${Feature}(supabase, input);

    revalidatePath("/${feature}s");
    return { success: true, data: item };
  } catch (error) {
    logger.error({ error }, "Failed to create ${feature}");
    return { success: false, error: "Failed to create ${feature}" };
  }
}

// ... update and delete actions
```

## Step 5: Create Components

### List Component (Client)

```typescript
// app/(protected)/$ARGUMENTS/components/${Feature}List.tsx
"use client";

import { useState } from "react";
import { ${Feature}Item } from "./${Feature}Item";

export function ${Feature}List({ items }: { items: ${Feature}[] }) {
  const [expandedId, setExpandedId] = useState<string | null>(null);

  return (
    <div className="space-y-2">
      {items.map((item) => (
        <${Feature}Item
          key={item.id}
          item={item}
          isExpanded={expandedId === item.id}
          onToggleExpand={() =>
            setExpandedId(expandedId === item.id ? null : item.id)
          }
        />
      ))}
    </div>
  );
}
```

### Item Component with Sheet

```typescript
// app/(protected)/$ARGUMENTS/components/${Feature}Item.tsx
"use client";

import { Sheet, SheetContent, SheetHeader, SheetTitle } from "@/components/ui/sheet";
import { Card, CardContent } from "@/components/ui/card";

interface ${Feature}ItemProps {
  item: ${Feature};
  isExpanded: boolean;
  onToggleExpand: () => void;
}

export function ${Feature}Item({ item, isExpanded, onToggleExpand }: ${Feature}ItemProps) {
  return (
    <>
      <Card
        className="cursor-pointer hover:bg-muted/50 transition-colors"
        onClick={onToggleExpand}
      >
        <CardContent className="p-4">
          <h3 className="font-medium text-foreground">{item.title}</h3>
          <p className="text-sm text-muted-foreground">{item.description}</p>
        </CardContent>
      </Card>

      <Sheet open={isExpanded} onOpenChange={onToggleExpand}>
        <SheetContent className="w-full sm:max-w-2xl">
          <SheetHeader>
            <SheetTitle>{item.title}</SheetTitle>
          </SheetHeader>
          {/* Detail content */}
        </SheetContent>
      </Sheet>
    </>
  );
}
```

## Step 6: Create Repository (if needed)

If the feature needs a new table:

1. First create the schema: `/create-migration add_${feature}_table`
2. Then create repository at `app/_shared/repositories/${feature}.repository.ts`

## Checklist

- [ ] Directory structure created
- [ ] Server Component page created
- [ ] Server Actions created with proper patterns
- [ ] List component with expandable items
- [ ] Item component with Sheet details
- [ ] Form component for create/edit
- [ ] Repository exists (or created)
- [ ] All imports use correct paths

### Pr


# PR Command

Create a pull request following team conventions.

## Pre-Flight Checks

Before creating PR, verify:

```bash
# Tests pass
npm run test:ci

# TypeScript compiles
npm run typecheck

# Linting passes
npm run fix

# Branch is up to date
git fetch origin main
```

## PR Creation Process

### Step 1: Gather Context

```bash
# Current branch
git branch --show-current

# Status
git status

# All commits since branching from main
git log main..HEAD --oneline

# Full diff
git diff main...HEAD --stat
```

### Step 2: Analyze Changes

I'll review ALL commits (not just the latest) to understand:
- What was changed
- Why it was changed
- What areas are affected

### Step 3: Generate PR

```bash
gh pr create --title "TYPE: Description" --body "$(cat <<'EOF'
## Summary
- What this PR does
- Why this change is needed
- Key decisions made

## Changes
- List of specific changes
- Organized by area/component

## Test plan
- [ ] Tests pass locally (`npm run test:ci`)
- [ ] TypeScript compiles (`npm run typecheck`)
- [ ] Linting passes (`npm run fix`)
- [ ] Manual testing: [describe what to test]

## Screenshots (if UI changes)
[Add screenshots here]

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
EOF
)"
```

## PR Title Convention

Use conventional commits:
- `feat:` New feature
- `fix:` Bug fix
- `refactor:` Code restructuring
- `docs:` Documentation
- `test:` Tests
- `chore:` Maintenance

Examples:
- `feat: Add call cancellation with reason tracking`
- `fix: Resolve timezone bug in booking emails`
- `refactor: Extract repository pattern for leads`

## PR Body Sections

### Summary
1-3 bullet points explaining:
- What the PR accomplishes
- Why the change is needed
- Any important context

### Changes
Organized list of:
- Files modified
- Features added
- Bugs fixed

### Test Plan
- [ ] Automated tests
- [ ] Manual testing steps
- [ ] Edge cases considered

## Common Issues

### Branch Not Pushed

```bash
git push -u origin $(git branch --show-current)
```

### Conflicts with Main

```bash
git fetch origin main
git rebase origin/main
# Fix conflicts
git push --force-with-lease
```

### Missing gh CLI

```bash
brew install gh
gh auth login
```

## Output

After creating PR:

```markdown
## PR Created Successfully

**Title**: feat: Add call cancellation with reason tracking
**URL**: https://github.com/[YOUR_ORG]/[YOUR_REPO]/pull/123
**Branch**: feature/call-cancellation â†’ main

**Commits Included**: 5
- abc1234 feat: Add cancellation_reason column
- def5678 feat: Update cancelCallAction
- ghi9012 feat: Add CancelDialog component
- jkl3456 test: Add tests for cancellation
- mno7890 docs: Update CLAUDE.md

**Files Changed**: 8
**Additions**: +234
**Deletions**: -12
```

### Review


# Code Review Command

Review recent code changes for pattern compliance and best practices.

## What This Command Does

1. **Identifies changes** - Uses `git diff` to see what's been modified
2. **Checks patterns** - Verifies compliance with codebase standards
3. **Reports issues** - Provides actionable feedback by severity

## Review Process

### Step 1: Get Recent Changes

```bash
git diff --name-only HEAD~5
```

Or if working on a branch:
```bash
git diff --name-only main...HEAD
```

### Step 2: Check Each Modified File

For each changed file, verify compliance with these patterns:

#### Repository Files (`*.repository.ts`)
- [ ] Uses `select(*)` not column picking
- [ ] Accepts `SupabaseClient` as first parameter
- [ ] Uses generated types from `database.types.ts`
- [ ] Does NOT manually filter by `organization_id`
- [ ] Uses Pino logger, not console.log

#### Server Actions (`actions.ts`)
- [ ] Has `"use server"` directive
- [ ] Uses repository functions (no direct Supabase)
- [ ] Calls `revalidatePath()` after mutations
- [ ] Returns `{ success, data/error }` structure
- [ ] Uses Pino logger

#### React Components (`*.tsx`)
- [ ] Uses shadcn/ui components, no raw HTML
- [ ] Uses CSS variables, no hardcoded colors
- [ ] Sheet components use single toggle handler
- [ ] DataGrid uses shadcn themes
- [ ] Has `"use client"` only when needed

#### Database Files (`*.sql`)
- [ ] Tables have `organization_id`
- [ ] RLS is enabled
- [ ] Org isolation policy exists

### Step 3: Report Findings

Organize issues by severity:

## Output Format

```markdown
# Code Review: [date]

## Summary
- Files reviewed: X
- Critical issues: X
- Warnings: X
- Suggestions: X

## Critical Issues (MUST FIX)

### [File: path/to/file.ts]
- **Line XX**: [Issue description]
  - **Pattern violated**: [Which pattern]
  - **Fix**: [How to fix]

## Warnings (SHOULD FIX)

[Similar format]

## Suggestions (CONSIDER)

[Similar format]

## Files Reviewed
- path/to/file1.ts âœ… / âš ï¸ / âŒ
- path/to/file2.tsx âœ… / âš ï¸ / âŒ
```

## Quick Pattern Reference

| Pattern | Correct | Wrong |
|---------|---------|-------|
| Select | `select(*)` | `select("id, name")` |
| Supabase in actions | Repository | `supabase.from()` |
| After mutation | `revalidatePath()` | (skip) |
| Colors | `bg-primary` | `bg-blue-500` |
| Button | `<Button>` | `<button>` |
| Sheet toggle | `onOpenChange={toggle}` | separate handlers |

## Reference Documentation

For detailed patterns, see:
- `.claude/skills/repository-pattern/SKILL.md`
- `.claude/skills/server-action/SKILL.md`
- `.claude/skills/component-creation/SKILL.md`
- `CLAUDE.md` in project root

### Test


# Test Command

Run tests and analyze any failures.

**Target**: `$ARGUMENTS` (or all tests if not specified)

## Test Commands

```bash
# Run all tests (CI mode - single run)
npm run test:ci

# Run specific file
npm run test -- $ARGUMENTS

# Run tests matching pattern
npm run test -- -t "pattern"

# Run with coverage
npm run test:coverage

# Run E2E tests
npm run test:e2e
```

## Test Analysis Process

### Step 1: Run Tests

```bash
npm run test:ci
```

Or for specific target:
```bash
npm run test -- $ARGUMENTS
```

### Step 2: Parse Results

For each failing test, I'll identify:
- Test file location
- Test name/description
- Error message
- Stack trace

### Step 3: Analyze Root Cause

For each failure, determine if:
1. **Test is wrong** - Test expectations need updating
2. **Source is wrong** - Code has a bug
3. **Mock is wrong** - External dependencies not mocked correctly
4. **Environment issue** - Setup/teardown problem

### Step 4: Suggest Fixes

Provide specific fixes for each failure.

## Common Test Issues

### Mock Not Working

```typescript
// âŒ Wrong - Import before mock
import { myFunction } from "./module";
vi.mock("./dependency");

// âœ… Correct - Mock before import
vi.mock("./dependency");
import { myFunction } from "./module";
```

### Async Test Timeout

```typescript
// Add longer timeout
it("should handle slow operation", async () => {
  // ...
}, 10000);

// Or use fake timers
vi.useFakeTimers();
```

### Missing Supabase Mock

```typescript
const mockSupabase = {
  from: vi.fn(() => ({
    select: vi.fn(() => ({
      eq: vi.fn(() => ({
        single: vi.fn(() => Promise.resolve({ data: mockData, error: null })),
      })),
    })),
  })),
};

vi.mock("@/app/_shared/lib/supabase/server", () => ({
  createClient: vi.fn(() => Promise.resolve(mockSupabase)),
}));
```

### Missing Clerk Mock

```typescript
vi.mock("@clerk/nextjs/server", () => ({
  auth: vi.fn(() => ({ orgId: "test-org", userId: "test-user" })),
  currentUser: vi.fn(() => Promise.resolve({ id: "test-user" })),
}));
```

## Output Format

```markdown
# Test Results

**Command**: `npm run test:ci`
**Status**: âœ… Passing / âŒ X failing

## Passing Tests
- `path/to/test.ts` - 5 tests âœ…

## Failing Tests

### 1. path/to/failing.test.ts > describe > test name

**Error**:
```
Expected: X
Received: Y
```

**Root Cause**: [Analysis]

**Fix**:
```typescript
// Code change needed
```

## Summary
- Total: X tests
- Passing: Y
- Failing: Z
- Coverage: XX%
```

## Test File Patterns

Tests should be in `__tests__` directories:

```
app/(protected)/calls/actions/
â”œâ”€â”€ cancel-call.ts
â””â”€â”€ __tests__/
    â””â”€â”€ cancel-call.test.ts
```

## Quick Test Commands

| Command | Purpose |
|---------|---------|
| `npm run test` | Watch mode |
| `npm run test:ci` | Single run |
| `npm run test -- path` | Specific file |
| `npm run test -- -t "name"` | By name |
| `npm run test:coverage` | With coverage |
| `npm run test:e2e` | E2E tests |

