---
title: "Server Action"
description: "Create server actions following your project's established patterns. Use when writing mutations, form submissions, data operations, or cache invalidation. Enforces repository usage, revalidatePath, structured returns, and route colocation."
---

# Server Action Skill

## When This Skill Activates

This skill automatically activates when you:
- Create or modify server actions (`actions.ts`)
- Write mutation logic (create, update, delete)
- Handle form submissions
- Need to invalidate cache after data changes

## Core Rules (MUST Follow)

### 1. Always Use Repository Functions

**NEVER use direct Supabase queries** in server actions:

```typescript
// ❌ WRONG - Direct Supabase in server action
export async function createCallAction(data: CreateCallInput) {
  const supabase = await createClient();
  const { data: call, error } = await supabase
    .from("calls")
    .insert(data)
    .select("*")
    .single();
  // ...
}

// ✅ CORRECT - Use repository
import { createCall } from "@/app/_shared/repositories/calls.repository";

export async function createCallAction(data: CreateCallInput) {
  const supabase = await createClient();
  const call = await createCall(supabase, data);
  // ...
}
```

**Why**: Repository layer provides consistent query patterns, type safety, and single source of truth.

### 2. Always Call revalidatePath() After Mutations

**EVERY mutation MUST invalidate the cache**:

```typescript
// ❌ WRONG - Missing cache invalidation
export async function updateCallAction(id: string, data: UpdateCallInput) {
  const supabase = await createClient();
  await updateCall(supabase, id, data);
  return { success: true };
  // User sees stale data!
}

// ✅ CORRECT - Invalidate cache
import { revalidatePath } from "next/cache";

export async function updateCallAction(id: string, data: UpdateCallInput) {
  const supabase = await createClient();
  await updateCall(supabase, id, data);

  revalidatePath("/calls");           // Invalidate list
  revalidatePath(`/calls/${id}`);     // Invalidate detail
  revalidatePath("/dashboard");        // Related pages

  return { success: true };
}
```

### 3. Return Structured Response

**ALL server actions MUST return `{ success, data?, error? }`**:

```typescript
// ❌ WRONG - Throwing or returning raw data
export async function getCallAction(id: string) {
  const call = await getCallById(id);
  if (!call) throw new Error("Not found");
  return call;
}

// ✅ CORRECT - Structured response
export async function getCallAction(id: string) {
  try {
    const call = await getCallById(id);
    if (!call) {
      return { success: false, error: "Call not found" };
    }
    return { success: true, data: call };
  } catch (error) {
    logger.error({ error, id }, "Failed to fetch call");
    return { success: false, error: "Failed to fetch call" };
  }
}
```

### 4. Colocate with Route

**Server actions belong in the route's `actions.ts`**, not in shared folders:

```
app/(protected)/calls/
├── page.tsx
├── actions.ts          # ✅ Server actions here
└── components/
    └── CallForm.tsx    # Uses actions from ../actions.ts

# ❌ WRONG - Don't put in shared
app/_shared/actions/calls.ts
```

### 5. Use Module Logger

**NEVER use console.log**:

```typescript
import { createModuleLogger } from "@/app/_shared/lib/logger";
const logger = createModuleLogger("calls-actions");

// ✅ Correct
logger.info({ callId }, "Creating call");
logger.error({ error }, "Failed to create call");

// ❌ Wrong
console.log("Creating call...");
console.error(error);
```

### 6. Add "use server" Directive

**MUST be at the top of file or function**:

```typescript
// ✅ File-level (preferred)
"use server";

import { ... } from "...";

export async function myAction() { ... }

// ✅ Function-level (when mixing with client code)
export async function myAction() {
  "use server";
  // ...
}
```

## Server Action Template

Full CRUD template with client component usage: `references/server-action-template.ts`

## Reference Implementation

See canonical examples at:
- `app/(protected)/calls/actions.ts` - Full server actions implementation
- `app/(protected)/scheduler/actions/` - Multiple action files for complex routes

## Common Mistakes to Avoid

1. **Direct Supabase in actions** - Always use repository
2. **Missing revalidatePath()** - Users see stale data
3. **Throwing errors** - Return structured `{ success, error }`
4. **Wrong location** - Keep in route's actions.ts
5. **Using console.log** - Use Pino logger
6. **Missing "use server"** - Required directive

## Quick Reference

| Pattern | Correct | Wrong |
|---------|---------|-------|
| Data access | Repository functions | `supabase.from()` |
| After mutation | `revalidatePath()` | (nothing) |
| Response | `{ success, data/error }` | throw / raw data |
| Location | `route/actions.ts` | `_shared/actions/` |
| Logging | `logger.info()` | `console.log()` |
| Directive | `"use server"` at top | (missing) |

## Reference: server-action-template.ts

```tsx
// Reference: Full server action template with all patterns
// Usage: Copy and adapt for new route actions

"use server";

import { revalidatePath } from "next/cache";
import { createModuleLogger } from "@/app/_shared/lib/logger";
import { createClient } from "@/app/_shared/lib/supabase/server";
import type {
	EntityInsert,
	EntityUpdate,
} from "@/app/_shared/repositories/entity.repository";
import {
	createEntity,
	deleteEntity,
	getEntityById,
	updateEntity,
} from "@/app/_shared/repositories/entity.repository";

const logger = createModuleLogger("entity-actions");

// Types for action responses
type ActionResponse<T> =
	| { success: true; data: T }
	| { success: false; error: string };

/**
 * Get entity by ID
 */
export async function getEntityAction(
	id: string,
): Promise<ActionResponse<Entity>> {
	logger.info({ id }, "Server action: getEntity called");

	try {
		const supabase = await createClient();
		const entity = await getEntityById(supabase, id);

		if (!entity) {
			return { success: false, error: "Entity not found" };
		}

		return { success: true, data: entity };
	} catch (error) {
		logger.error({ error, id }, "Server action: getEntity failed");
		return { success: false, error: "Failed to fetch entity" };
	}
}

/**
 * Create new entity
 */
export async function createEntityAction(
	input: EntityInsert,
): Promise<ActionResponse<Entity>> {
	logger.info("Server action: createEntity called");

	try {
		const supabase = await createClient();
		const entity = await createEntity(supabase, input);

		// Cache invalidation
		revalidatePath("/entities");
		revalidatePath("/dashboard");

		logger.info({ entityId: entity.id }, "Entity created successfully");
		return { success: true, data: entity };
	} catch (error) {
		logger.error({ error }, "Server action: createEntity failed");
		return { success: false, error: "Failed to create entity" };
	}
}

/**
 * Update existing entity
 */
export async function updateEntityAction(
	id: string,
	updates: EntityUpdate,
): Promise<ActionResponse<Entity>> {
	logger.info({ id }, "Server action: updateEntity called");

	try {
		const supabase = await createClient();
		const entity = await updateEntity(supabase, id, updates);

		// Cache invalidation
		revalidatePath("/entities");
		revalidatePath(`/entities/${id}`);
		revalidatePath("/dashboard");

		logger.info({ entityId: entity.id }, "Entity updated successfully");
		return { success: true, data: entity };
	} catch (error) {
		logger.error({ error, id }, "Server action: updateEntity failed");
		return { success: false, error: "Failed to update entity" };
	}
}

/**
 * Delete entity
 */
export async function deleteEntityAction(
	id: string,
): Promise<ActionResponse<void>> {
	logger.info({ id }, "Server action: deleteEntity called");

	try {
		const supabase = await createClient();
		await deleteEntity(supabase, id);

		// Cache invalidation
		revalidatePath("/entities");
		revalidatePath("/dashboard");

		logger.info({ entityId: id }, "Entity deleted successfully");
		return { success: true, data: undefined };
	} catch (error) {
		logger.error({ error, id }, "Server action: deleteEntity failed");
		return { success: false, error: "Failed to delete entity" };
	}
}

// --- Client Component Usage ---
// "use client";
//
// import { useTransition } from "react";
// import { useRouter } from "next/navigation";
// import { createEntityAction } from "../actions";
//
// export function EntityForm() {
//   const router = useRouter();
//   const [isPending, startTransition] = useTransition();
//
//   async function handleSubmit(formData: FormData) {
//     startTransition(async () => {
//       const result = await createEntityAction({
//         title: formData.get("title") as string,
//       });
//
//       if (result.success) {
//         router.refresh();
//       } else {
//         // Show error toast with result.error
//       }
//     });
//   }
//
//   return (
//     <form action={handleSubmit}>
//       <Button type="submit" disabled={isPending}>
//         {isPending ? "Creating..." : "Create"}
//       </Button>
//     </form>
//   );
// }

```
