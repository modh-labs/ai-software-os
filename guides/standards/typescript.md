---
title: "TypeScript Conventions"
description: "TypeScript standards for all apps in the monorepo."
tags: ["typescript", "architecture"]
category: "standards"
author: "Imran Gardezi"
publishable: true
---
# TypeScript Standards

> **Applies to:** All apps in the monorepo (web, admin, future apps)
> **Last Updated:** January 2026

This document defines TypeScript conventions for all applications in your monorepo. Every app MUST follow these patterns for consistent, type-safe code.

---

## Strict Mode

### Required Configuration

Every `tsconfig.json` MUST include strict mode:

```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noImplicitReturns": true
  }
}
```

### No `any` Types

**NEVER use `any`** - it defeats the purpose of TypeScript:

```typescript
// WRONG - any type
function processData(data: any) { ... }

// RIGHT - proper typing
function processData(data: ProcessDataInput) { ... }

// RIGHT - unknown for truly unknown data (requires narrowing)
function processData(data: unknown) {
  if (isValidInput(data)) {
    // Now safe to use
  }
}
```

---

## Database Types

### Use Generated Types ONLY

All database types come from `database.types.ts` generated by Supabase:

```typescript
// RIGHT - Use generated types
import type { Database } from '@/app/_shared/lib/supabase/database.types';

type Call = Database['public']['Tables']['calls']['Row'];
type CallInsert = Database['public']['Tables']['calls']['Insert'];
type CallUpdate = Database['public']['Tables']['calls']['Update'];
```

### NEVER Create Custom Interfaces

```typescript
// WRONG - Custom interface for database types
export interface CreateBookingLinkInput {
  title: string;
  description?: string | null;
  duration_minutes: number;
  // ... manually defining all fields
}

// RIGHT - Use generated types
export type CreateBookingLinkInput = Database['public']['Tables']['call_booking_links']['Insert'];
```

### Why This Matters

- Schema changes automatically update types via `pnpm db:types`
- No manual maintenance of type definitions
- Types always match actual database schema
- Prevents "Frankenstein types" (half-correct interfaces)

---

## The `select *` Rule

### Always Use `select *`

**This is non-negotiable.** Every Supabase query MUST use `select *`:

```typescript
// RIGHT - Always select all columns
.select("*")
.select("*, lead:leads(*)")
.select("*, lead:leads(*), closer:users(*)")

// WRONG - Never pick specific columns
.select("id, title, created_at")
.select("id, lead_id, closer_id, scheduled_at")
```

### Why `select *` is Required

| Problem with Column Selection | Consequence |
|------------------------------|-------------|
| Missing fields | `null` values when syncing to database |
| Schema changes | Must update all query column lists |
| Easy to forget fields | Causes bugs like missing booking IDs |
| Types don't match reality | Runtime errors |

### Type Safety with `select *`

```typescript
// The result type matches the full Row type
const { data } = await supabase.from('calls').select('*').single();
// data is fully typed as Database['public']['Tables']['calls']['Row']

// With relations
const { data } = await supabase
  .from('calls')
  .select('*, lead:leads(*)')
  .single();
// data.lead is fully typed as Database['public']['Tables']['leads']['Row']
```

---

## Type Exports

### Re-export from Central Location

Shared types live in `_shared/types/` and re-export from database types:

```typescript
// _shared/types/calls.ts
import type { Database } from '../lib/supabase/database.types';

// Re-export generated types with better names
export type Call = Database['public']['Tables']['calls']['Row'];
export type CallInsert = Database['public']['Tables']['calls']['Insert'];
export type CallUpdate = Database['public']['Tables']['calls']['Update'];

// Derived types (computed from base types)
export type CallWithLead = Call & {
  lead: Database['public']['Tables']['leads']['Row'];
};

// Status enums (if not in DB)
export type CallStatus = 'scheduled' | 'completed' | 'cancelled' | 'no_show';
```

### Import Pattern

```typescript
// Component file
import type { Call, CallWithLead } from '@/app/_shared/types/calls';
```

---

## Zod Validation Schemas

### One Schema File Per Route

```
_shared/validation/
├── leads.schema.ts        # Lead-related schemas
├── calls.schema.ts        # Call-related schemas
├── scheduler.schema.ts    # Booking link schemas
└── settings.schema.ts     # Settings schemas
```

### Schema Structure

```typescript
// _shared/validation/leads.schema.ts
import { z } from 'zod';

// Create input schema
export const createLeadSchema = z.object({
  name: z.string().min(1, 'Name is required').max(200),
  email: z.string().email('Invalid email'),
  phone: z.string().optional(),
  source: z.enum(['web', 'referral', 'api']),
  metadata: z.record(z.unknown()).optional(),
});

// Update schema (partial + id)
export const updateLeadSchema = createLeadSchema.partial().extend({
  id: z.string().uuid(),
});

// Infer types from schemas
export type CreateLeadInput = z.infer<typeof createLeadSchema>;
export type UpdateLeadInput = z.infer<typeof updateLeadSchema>;
```

### Usage in Server Actions

```typescript
'use server'
import { createLeadSchema, type CreateLeadInput } from '@/app/_shared/validation/leads.schema';

export async function createLead(input: CreateLeadInput) {
  // Validate at runtime (input could come from form)
  const validated = createLeadSchema.parse(input);

  // Now safe to use validated data
  return await leadsRepository.create(supabase, validated);
}
```

---

## Naming Conventions

### Files

| Type | Convention | Example |
|------|------------|---------|
| Components | PascalCase | `CallTable.tsx` |
| Utilities | kebab-case | `call-utils.ts` |
| Types | kebab-case | `calls.types.ts` |
| Schemas | kebab-case + `.schema` | `calls.schema.ts` |
| Repositories | kebab-case + `.repository` | `calls.repository.ts` |
| Server Actions | kebab-case | `create-call.ts` or `actions.ts` |
| Tests | same-as-source + `.test` | `calls.repository.test.ts` |

### Types and Interfaces

```typescript
// Types - Use for object shapes, unions, computed types
type CallStatus = 'scheduled' | 'completed' | 'cancelled';
type CallWithLead = Call & { lead: Lead };

// Interfaces - Use for extendable contracts (rare in this codebase)
interface Repository<T> {
  list(supabase: SupabaseClient): Promise<T[]>;
  create(supabase: SupabaseClient, data: unknown): Promise<T>;
}
```

### Functions

```typescript
// Async functions - verb + noun
async function createCall(data: CallInsert): Promise<Call>
async function listCallsForOrg(): Promise<Call[]>
async function updateCallStatus(id: string, status: CallStatus): Promise<Call>

// Boolean functions - is/has/can prefix
function isCallScheduled(call: Call): boolean
function hasPaymentVerified(call: Call): boolean
function canEditCall(call: Call, userId: string): boolean

// Event handlers - handle + event
function handleSubmit(e: FormEvent): void
function handleCallClick(callId: string): void
```

---

## Import Organization

### Order

```typescript
// 1. React/Next.js
import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

// 2. External libraries
import { format } from 'date-fns';
import { z } from 'zod';

// 3. Internal absolute imports
import { Button } from '@/components/ui/button';
import { createClient } from '@/app/_shared/lib/supabase/server';
import type { Call } from '@/app/_shared/types/calls';

// 4. Relative imports
import { CallTable } from './components/CallTable';
import { createCallAction } from './actions';
```

### Type-Only Imports

Use `import type` for type-only imports:

```typescript
// RIGHT - Type-only import
import type { Database } from '@/app/_shared/lib/supabase/database.types';
import type { Call, CallWithLead } from '@/app/_shared/types/calls';

// WRONG - Regular import for types
import { Database } from '@/app/_shared/lib/supabase/database.types';
```

---

## Function Signatures

### Repository Functions

```typescript
// Standard repository function signature
export async function listCalls(
  supabase: SupabaseClient<Database>,
  filters?: { status?: CallStatus }
): Promise<Call[]>
```

Key patterns:
- `supabase` as first parameter (dependency injection)
- Optional `filters` object for query parameters
- Return type explicitly specified

### Server Actions

```typescript
// Standard server action signature
export async function createCall(
  data: CreateCallInput
): Promise<{ success: true; data: Call } | { success: false; error: string }>
```

Key patterns:
- Validated input type
- Discriminated union return for success/error

---

## Generics

### Use When Type Varies

```typescript
// Generic repository pattern
async function getById<T extends { id: string }>(
  supabase: SupabaseClient<Database>,
  table: string,
  id: string
): Promise<T | null>

// Generic list response
interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
}
```

### Don't Overuse

```typescript
// WRONG - Unnecessary generic
function formatDate<T extends Date>(date: T): string

// RIGHT - Just use the type
function formatDate(date: Date): string
```

---

## Null vs Undefined

### Database Fields

Supabase uses `null` for missing values:

```typescript
// Database type
type Call = {
  notes: string | null;  // Can be null in DB
};

// Handle nulls explicitly
const displayNotes = call.notes ?? 'No notes';
```

### Optional Parameters

TypeScript uses `undefined` for optional:

```typescript
// Optional parameter
function createCall(data: CallInsert, options?: CreateOptions): Promise<Call>

// Default to undefined, not null
const status = options?.status ?? 'scheduled';
```

---

## Checklist for New Code

- [ ] No `any` types used
- [ ] Database types from generated `database.types.ts`
- [ ] Zod schemas for all user input
- [ ] `select *` in all Supabase queries
- [ ] `import type` for type-only imports
- [ ] Explicit return types on exported functions
- [ ] Proper null handling with `??` or explicit checks
- [ ] Files named according to conventions

---

## Related Documentation

- [Database Standards](./database.md) - Repository pattern, type generation
- [Testing Standards](./testing.md) - Type-safe test patterns
